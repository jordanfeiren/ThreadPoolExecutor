首先理解voliate作用
可见性与Java内存模型相关，每个线程都有自己的缓存空间cache，都是对cache进行修改，修改完然后对主存修改，
这就带来了问题，有可能一个线程在将共享变量修改后，还没有来的及将缓存中的变量返回给主存中，另外一个线程就对共享变量进行修改，
那么这个线程拿到的值是主存中未被修改的值，这就是可见性的问题。

volatile很好的保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，
但是加了这个指令后，会引发两件事情：

将当前处理器缓存行的数据写回到系统内存
这个写回内存的操作会使得在其他处理器缓存了该内存地址无效

一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，
最后将得到的新值写会到缓存中。
线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，
主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。
问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，
得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，也不能保证对它修饰的变量具有原子性。


CAS本质上是通过死循环不断地比较当前获取到的变量值（期望值），通过CAS与内存中变量最新的值（内存值）作比较，
只要一致的话就设置为新的值（更新值），否则的话重新获取再次比较直到CAS成功为止。

执行CAS操作时，如果当前内存值和预期的值一致的话就将内存值原子性的设置为更新值，否则的话不断地尝试直到成功为止，
CAS的本质是通过死循环实现的。
例如线程A和线程B此时都在尝试修改变量a=1的值加一。
此刻线程A开始执行，获取变量a在内存中的值为1，接下来即将执行CAS操作，
此时cpu进行调度B线程获取执行权，依旧先获取变量a此刻在内存中的值为1，执行CAS操作，将预期值1与内存值1做比较发现是相同的，CAS成功，
将变量a自增，此时内存中的a值为2，线程B运行结束退出。cpu调度线程A获取执行权，继续执行上一步的CAS操作，
将预期值1与内存值2做比较发现不相同（被线程B修改了），CAS失败，继续下一次循环，
继续获取变量a在内存中的值为2，执行CAS操作，此时预期值2和内存值2相同，CAS成功，将变量a自增，最终变量a的值变为3。



